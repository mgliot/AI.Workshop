@page "/"

@using System.ComponentModel
@using System.Diagnostics
@using AI.Workshop.Common
@using AI.Workshop.Common.Toon

@inject IChatClient ChatClient
@inject NavigationManager Nav
@inject IConfiguration Configuration
@inject ChatSettingsService Settings
@inject GuardrailsService Guardrails
@inject RagService RagService
@inject StudyGuideOrchestrator StudyGuideOrchestrator

@implements IDisposable

<PageTitle>AI Workshop Chat</PageTitle>

<ChatHeader OnNewChat="@ResetConversationAsync" OnSettingsClick="@ToggleSettings" Settings="@Settings" />

<div class="agent-container page-width">
    <AgentSelector Settings="@Settings" OnAgentChanged="@OnAgentChanged" />
</div>

@if (guardrailAlert != null)
{
    <div class="page-width">
        <GuardrailAlert 
            AlertType="@guardrailAlert.Type" 
            Title="@guardrailAlert.Title" 
            Message="@guardrailAlert.Message"
            ViolationType="@guardrailAlert.ViolationType"
            OnDismiss="@DismissAlert" />
    </div>
}

<ChatMessageList Messages="@messages" InProgressMessage="@currentResponseMessage">
    <NoMessagesContent>
        <div>
            <p>To get started, ask questions about your PDF documents.</p>
            <p><strong>Current Agent:</strong> @AgentMetadata.Agents[Settings.SelectedAgent].Description</p>
        </div>
        @foreach (var file in availablePdfFiles)
        {
            <ChatCitation File="@file"/>
        }
    </NoMessagesContent>
</ChatMessageList>

<div class="chat-container">
    @if (Settings.CurrentStats != null)
    {
        <div class="page-width">
            <StatsBar Stats="@Settings.CurrentStats" ToonEnabled="@Settings.ToonEnabled" />
        </div>
    }
    <ChatSuggestions OnSelected="@AddUserMessageAsync" @ref="@chatSuggestions" />
    <ChatInput OnSend="@AddUserMessageAsync" @ref="@chatInput" />
</div>

<SettingsPanel IsOpen="@settingsOpen" OnClose="@CloseSettings" Settings="@Settings" />

@code {
    private string SystemPrompt = string.Empty;
    private bool settingsOpen = false;
    private AlertInfo? guardrailAlert;
    private string? pendingDownloadMessage;

    private readonly ChatOptions chatOptions = new()
    {
        Temperature = 0.2f,
        MaxOutputTokens = 2000,
        ToolMode = ChatToolMode.Auto,
        Tools = []
    };

    private readonly List<ChatMessage> messages = new();
    private CancellationTokenSource? currentResponseCancellation;
    private ChatMessage? currentResponseMessage;
    private ChatInput? chatInput;
    private ChatSuggestions? chatSuggestions;
    private IEnumerable<string> availablePdfFiles = [];

    protected override async Task OnInitializedAsync()
    {
        availablePdfFiles = await RagService.ListDocumentsAsync();
    }

    protected override void OnInitialized()
    {
        LoadAgentPrompt();
        ConfigureTools();
        Settings.OnSettingsChanged += StateHasChanged;
    }

    private void LoadAgentPrompt()
    {
        var agentName = Settings.SelectedAgent.ToString();
        SystemPrompt = PromptyHelper.GetSystemPrompt(agentName);
        
        messages.Clear();
        messages.Add(new(ChatRole.System, SystemPrompt));
    }

    private void ConfigureTools()
    {
        chatOptions.Tools!.Clear();

        // Add search tool
        chatOptions.Tools.Add(AIFunctionFactory.Create(
            RagService.SearchAsync,
            "SearchDocuments",
            "Searches for information in PDF documents using a phrase or keyword"));

        // Add list documents tool for PDF summarization and StudyGuide
        if (Settings.SelectedAgent == AgentType.PDFSummarization || Settings.SelectedAgent == AgentType.StudyGuide)
        {
            chatOptions.Tools.Add(AIFunctionFactory.Create(
                RagService.ListDocumentsAsync,
                "ListDocuments",
                "Lists all available PDF documents that can be searched or summarized"));
        }

        // Add complete study guide generation for StudyGuide agent
        if (Settings.SelectedAgent == AgentType.StudyGuide)
        {
            chatOptions.Tools.Add(AIFunctionFactory.Create(
                GenerateCompleteStudyGuideAsync,
                "GenerateCompleteStudyGuide",
                "Generates a COMPLETE and DETAILED study guide for a PDF document. Processes all pages automatically."));
        }
    }

    [Description("Generates a complete study guide for a PDF document, processing all pages section by section automatically. Returns a PDF download link.")]
    private async Task<string> GenerateCompleteStudyGuideAsync(
        [Description("The exact filename of the PDF document")] string filename)
    {
        var result = await StudyGuideOrchestrator.GenerateCompleteStudyGuideAsync(filename, progress =>
        {
            Console.WriteLine(progress);
        });
        
        Console.WriteLine($"=== STUDY GUIDE RESULT ===");
        Console.WriteLine($"PDF File: {result.PdfFileName}");
        Console.WriteLine($"=========================");
        
        // Store the full message with download link to inject after LLM response
        pendingDownloadMessage = result.Message;
        
        // Return short confirmation to LLM - the full message with link will be injected separately
        return "GuÃ­a de estudio generada exitosamente.";
    }

    private async Task OnAgentChanged(AgentType agent)
    {
        LoadAgentPrompt();
        ConfigureTools();
        await ResetConversationAsync();
    }

    private void ToggleSettings() => settingsOpen = !settingsOpen;
    private void CloseSettings() => settingsOpen = false;
    private void DismissAlert() => guardrailAlert = null;

    private async Task AddUserMessageAsync(ChatMessage userMessage)
    {
        CancelAnyCurrentResponse();
        guardrailAlert = null;
        Settings.ClearCurrentStats();
        RagService.ClearLastComparison();

        var userInput = userMessage.Text ?? string.Empty;

        // Validate input with guardrails if enabled
        if (Settings.GuardrailsEnabled)
        {
            var inputResult = Guardrails.ValidateInput(userInput);
            if (!inputResult.IsAllowed)
            {
                guardrailAlert = new AlertInfo(
                    "blocked",
                    "Message Blocked",
                    inputResult.ViolationMessage ?? "Your message was blocked by content safety.",
                    inputResult.ViolationType?.ToString());
                StateHasChanged();
                return;
            }
            if (inputResult.RedactedContent != null)
            {
                guardrailAlert = new AlertInfo(
                    "redacted",
                    "Content Redacted",
                    "Some content in your message was redacted.",
                    inputResult.ViolationType?.ToString());
                userMessage = new ChatMessage(ChatRole.User, inputResult.RedactedContent);
            }
        }

        // Add the user message to the conversation
        messages.Add(userMessage);
        chatSuggestions?.Clear();
        await chatInput!.FocusAsync();

        // Start timing
        var stopwatch = Stopwatch.StartNew();

        // Stream and display a new response from the IChatClient
        var responseText = new TextContent("");
        currentResponseMessage = new ChatMessage(ChatRole.Assistant, [responseText]);
        currentResponseCancellation = new();
        UsageDetails? lastUsage = null;
        
        await foreach (var update in ChatClient.GetStreamingResponseAsync([.. messages], chatOptions, currentResponseCancellation.Token))
        {
            messages.AddMessages(update, filter: c => c is not TextContent);
            responseText.Text += update.Text;
            
            // Capture usage from the stream
            foreach (var usageContent in update.Contents.OfType<UsageContent>())
            {
                lastUsage ??= new UsageDetails();
                lastUsage.Add(usageContent.Details);
            }
            
            // Trigger UI update for streaming text
            await ChatMessageItem.NotifyChangedAsync(currentResponseMessage!);
            StateHasChanged();
        }

        stopwatch.Stop();

        // Track token usage
        if (lastUsage != null)
        {
            Settings.TokenTracker.RecordUsage(lastUsage);
        }

        // Update stats with timing and TOON comparison
        Settings.UpdateStats(new ResponseStats(
            ResponseTime: stopwatch.Elapsed,
            InputTokens: lastUsage?.InputTokenCount,
            OutputTokens: lastUsage?.OutputTokenCount,
            TotalTokens: lastUsage?.TotalTokenCount,
            ToonComparison: RagService.LastToonComparison));

        var responseContent = responseText.Text ?? string.Empty;

        // Validate output with guardrails if enabled
        if (Settings.GuardrailsEnabled)
        {
            var outputResult = Guardrails.ValidateOutput(responseContent);
            if (!outputResult.IsAllowed)
            {
                responseText.Text = "[Response blocked by guardrails]";
                guardrailAlert = new AlertInfo(
                    "blocked",
                    "Response Blocked",
                    outputResult.ViolationMessage ?? "The AI response was blocked by content safety.",
                    outputResult.ViolationType?.ToString());
            }
            else if (outputResult.RedactedContent != null)
            {
                responseText.Text = outputResult.RedactedContent;
            }
        }

        // Store the final response in the conversation, and begin getting suggestions
        messages.Add(currentResponseMessage!);
        currentResponseMessage = null;
        
        // If a study guide was generated, add the download message
        if (!string.IsNullOrEmpty(pendingDownloadMessage))
        {
            messages.Add(new ChatMessage(ChatRole.Assistant, pendingDownloadMessage));
            pendingDownloadMessage = null;
            StateHasChanged();
        }
        
        chatSuggestions?.Update(messages);
    }

    private void CancelAnyCurrentResponse()
    {
        // If a response was cancelled while streaming, include it in the conversation so it's not lost
        if (currentResponseMessage is not null)
        {
            messages.Add(currentResponseMessage);
        }

        currentResponseCancellation?.Cancel();
        currentResponseMessage = null;
    }

    private async Task ResetConversationAsync()
    {
        CancelAnyCurrentResponse();
        guardrailAlert = null;
        messages.Clear();
        messages.Add(new(ChatRole.System, SystemPrompt));
        chatSuggestions?.Clear();
        await chatInput!.FocusAsync();
    }

    public void Dispose()
    {
        Settings.OnSettingsChanged -= StateHasChanged;
        currentResponseCancellation?.Cancel();
    }

    private record AlertInfo(string Type, string Title, string Message, string? ViolationType);
}
